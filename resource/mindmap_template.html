<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ€ç»´å¯¼å›¾</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', 'SimHei', Arial, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            overflow: hidden;
            height: 100vh;
        }

        #mindmap {
            width: 100%;
            height: 100vh;
        }

        .node {
            cursor: pointer;
        }

        .node circle {
            stroke-width: 2px;
            transition: all 0.3s ease;
        }

        .node:hover circle {
            stroke-width: 4px;
            filter: brightness(1.2);
        }

        .node text {
            font-size: 13px;
            font-weight: 500;
            fill: #ffffff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .link {
            fill: none;
            stroke: rgba(255, 255, 255, 0.3);
            stroke-width: 1.5px;
        }

        /* æ ¹èŠ‚ç‚¹æ ·å¼ */
        .node.root circle {
            fill: #e94560;
            stroke: #ff6b6b;
            r: 15;
        }

        .node.root text {
            font-size: 16px;
            font-weight: bold;
        }

        /* ä¸€çº§èŠ‚ç‚¹æ ·å¼ */
        .node.level-1 circle {
            fill: #0f3460;
            stroke: #16213e;
            r: 10;
        }

        .node.level-1 text {
            font-size: 14px;
        }

        /* äºŒçº§èŠ‚ç‚¹æ ·å¼ */
        .node.level-2 circle {
            fill: #533483;
            stroke: #7952b3;
            r: 7;
        }

        /* ä¸‰çº§èŠ‚ç‚¹æ ·å¼ */
        .node.level-3 circle {
            fill: #4a6fa5;
            stroke: #6b93d6;
            r: 5;
        }

        /* æ§åˆ¶é¢æ¿ */
        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            z-index: 1000;
        }

        .controls button {
            display: block;
            width: 100%;
            margin: 5px 0;
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .controls button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        /* æç¤ºä¿¡æ¯ */
        .tooltip {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
            color: #333;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
    </style>
</head>

<body>
    <div class="controls">
        <button onclick="resetZoom()">é‡ç½®è§†å›¾</button>
        <button onclick="expandAll()">å±•å¼€å…¨éƒ¨</button>
        <button onclick="collapseAll()">æŠ˜å å…¨éƒ¨</button>
    </div>
    <div class="tooltip">ğŸ–±ï¸ æ»šè½®ç¼©æ”¾ | æ‹–æ‹½ç§»åŠ¨ | ç‚¹å‡»èŠ‚ç‚¹å±•å¼€/æŠ˜å </div>
    <div id="mindmap"></div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // æ€ç»´å¯¼å›¾æ•°æ®å°†ç”±Pythonæ³¨å…¥
        let mindmapData = {{ MINDMAP_DATA }};

        const margin = { top: 40, right: 200, bottom: 40, left: 100 };
        const width = window.innerWidth;
        const height = window.innerHeight;

        // è®¡ç®—èŠ‚ç‚¹æ•°é‡æ¥åŠ¨æ€è°ƒæ•´å¸ƒå±€
        function countNodes(node) {
            let count = 1;
            if (node.children) {
                node.children.forEach(child => {
                    count += countNodes(child);
                });
            }
            return count;
        }
        const nodeCount = countNodes(mindmapData);
        const dynamicHeight = Math.max(height, nodeCount * 25);

        // åˆ›å»ºSVG
        const svgElement = d3.select("#mindmap")
            .append("svg")
            .attr("width", width)
            .attr("height", height);

        // åˆ›å»ºç¼©æ”¾å®¹å™¨
        const g = svgElement.append("g")
            .attr("transform", `translate(${margin.left}, ${margin.top})`);

        // è®¾ç½®ç¼©æ”¾è¡Œä¸º
        const zoom = d3.zoom()
            .scaleExtent([0.3, 3])
            .on("zoom", (event) => {
                g.attr("transform", event.transform);
            });

        svgElement.call(zoom);

        // åˆ›å»ºæ°´å¹³æ ‘å¸ƒå±€
        const treeLayout = d3.tree()
            .size([dynamicHeight - margin.top - margin.bottom, width - margin.left - margin.right - 200]);

        // è½¬æ¢æ•°æ®ä¸ºå±‚æ¬¡ç»“æ„
        let root = d3.hierarchy(mindmapData);

        // åˆå§‹åªå±•å¼€å‰ä¸¤å±‚
        root.descendants().forEach((d, i) => {
            if (d.depth > 1) {
                d._children = d.children;
                d.children = null;
            }
        });

        // ç”¨äºç”Ÿæˆå”¯ä¸€ID
        let i = 0;

        // æ¸²æŸ“å‡½æ•°
        function update(source) {
            // è®¡ç®—æ–°å¸ƒå±€
            treeLayout(root);

            // è·å–æ‰€æœ‰èŠ‚ç‚¹å’Œè¿çº¿
            const nodes = root.descendants();
            const links = root.links();

            // è°ƒæ•´èŠ‚ç‚¹ä½ç½® (äº¤æ¢xå’Œyå®ç°æ°´å¹³å¸ƒå±€)
            nodes.forEach(d => {
                d.y = d.depth * 220;  // æ°´å¹³é—´è·
            });

            // ===== æ›´æ–°èŠ‚ç‚¹ =====
            const node = g.selectAll("g.node")
                .data(nodes, d => d.id || (d.id = ++i));

            // æ–°èŠ‚ç‚¹è¿›å…¥
            const nodeEnter = node.enter()
                .append("g")
                .attr("class", d => `node ${d.depth === 0 ? 'root' : 'level-' + Math.min(d.depth, 3)}`)
                .attr("transform", d => `translate(${source.y0 || 0},${source.x0 || 0})`)
                .on("click", (event, d) => {
                    // ç‚¹å‡»åˆ‡æ¢å±•å¼€/æŠ˜å 
                    if (d.children) {
                        d._children = d.children;
                        d.children = null;
                    } else if (d._children) {
                        d.children = d._children;
                        d._children = null;
                    }
                    update(d);
                });

            // æ·»åŠ åœ†åœˆ
            nodeEnter.append("circle")
                .attr("r", d => {
                    if (d.depth === 0) return 15;
                    if (d.depth === 1) return 10;
                    if (d.depth === 2) return 7;
                    return 5;
                })
                .style("fill", d => d._children ? "#e94560" : null);

            // æ·»åŠ æ–‡æœ¬
            nodeEnter.append("text")
                .attr("dy", "0.35em")
                .attr("x", d => d.children || d._children ? -15 : 15)
                .attr("text-anchor", d => d.children || d._children ? "end" : "start")
                .text(d => d.data.text)
                .clone(true).lower()
                .attr("stroke", "rgba(0,0,0,0.5)")
                .attr("stroke-width", 3);

            // åˆå¹¶æ–°æ—§èŠ‚ç‚¹
            const nodeUpdate = nodeEnter.merge(node);

            // è¿‡æ¸¡åŠ¨ç”»
            nodeUpdate.transition()
                .duration(500)
                .attr("transform", d => `translate(${d.y},${d.x})`);

            // æ›´æ–°åœ†åœˆæ ·å¼
            nodeUpdate.select("circle")
                .style("fill", d => d._children ? "#e94560" : null);

            // ç§»é™¤é€€å‡ºçš„èŠ‚ç‚¹
            node.exit()
                .transition()
                .duration(500)
                .attr("transform", d => `translate(${source.y},${source.x})`)
                .remove();

            // ===== æ›´æ–°è¿çº¿ =====
            const link = g.selectAll("path.link")
                .data(links, d => d.target.id);

            // æ–°è¿çº¿è¿›å…¥
            const linkEnter = link.enter()
                .insert("path", "g")
                .attr("class", "link")
                .attr("d", d => {
                    const o = { x: source.x0 || 0, y: source.y0 || 0 };
                    return diagonal(o, o);
                });

            // åˆå¹¶æ–°æ—§è¿çº¿
            const linkUpdate = linkEnter.merge(link);

            // è¿‡æ¸¡åŠ¨ç”»
            linkUpdate.transition()
                .duration(500)
                .attr("d", d => diagonal(d.source, d.target));

            // ç§»é™¤é€€å‡ºçš„è¿çº¿
            link.exit()
                .transition()
                .duration(500)
                .attr("d", d => {
                    const o = { x: source.x, y: source.y };
                    return diagonal(o, o);
                })
                .remove();

            // ä¿å­˜å½“å‰ä½ç½®ç”¨äºä¸‹æ¬¡è¿‡æ¸¡
            nodes.forEach(d => {
                d.x0 = d.x;
                d.y0 = d.y;
            });
        }

        // ç”Ÿæˆæ›²çº¿è·¯å¾„
        function diagonal(s, d) {
            return `M ${s.y} ${s.x}
                    C ${(s.y + d.y) / 2} ${s.x},
                      ${(s.y + d.y) / 2} ${d.x},
                      ${d.y} ${d.x}`;
        }

        // åˆå§‹æ¸²æŸ“
        root.x0 = dynamicHeight / 2;
        root.y0 = 0;
        update(root);

        // åˆå§‹ç¼©æ”¾ä»¥é€‚åº”è§†å›¾
        const initialTransform = d3.zoomIdentity
            .translate(margin.left, height / 2 - dynamicHeight / 2)
            .scale(0.9);
        svgElement.call(zoom.transform, initialTransform);

        // æ§åˆ¶å‡½æ•°
        function resetZoom() {
            svgElement.transition()
                .duration(750)
                .call(zoom.transform, initialTransform);
        }

        function expandAll() {
            root.descendants().forEach(d => {
                if (d._children) {
                    d.children = d._children;
                    d._children = null;
                }
            });
            update(root);
        }

        function collapseAll() {
            root.descendants().forEach(d => {
                if (d.children && d.depth > 0) {
                    d._children = d.children;
                    d.children = null;
                }
            });
            update(root);
        }

        // å“åº”çª—å£å¤§å°å˜åŒ–
        window.addEventListener('resize', () => {
            const newWidth = window.innerWidth;
            const newHeight = window.innerHeight;
            svgElement.attr("width", newWidth).attr("height", newHeight);
            treeLayout.size([dynamicHeight - margin.top - margin.bottom, newWidth - margin.left - margin.right - 200]);
            update(root);
            svgElement.call(zoom.transform, d3.zoomIdentity.translate(margin.left, newHeight / 2 - dynamicHeight / 2).scale(0.9));
        });
    </script>
</body>

</html>